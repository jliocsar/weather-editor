* as fs from node:fs
* as fsp from node:fs/promises
* as path from node:path
{ spawnSync } from child_process

{ Jimp, intToRGBA } from jimp

{ WeatherLtxParser, type ParsedWeatherLtxSection } from ./ltx-parser.civet
* as Types from ./typedefs.civet

export Types

type TIterateResult<TWeatherName extends Types.WeatherName> =
  weatherName: TWeatherName
  weather: Partial<ParsedWeatherLtxSection>

type TWeatherEditorArgs =
  root: string
  debug?: boolean
  skyTexturesRoot?: string

type TPatchArgs<TWeatherName extends Types.WeatherName, TTimeRange extends Types.WeatherTimeRange> =
  weatherName: TWeatherName
  timeRange: TTimeRange
  with: (def: Types.WeatherDefinition, time: Types.WeatherTime) => void

LTX_EXT := '.ltx'
IS_LINUX := process.platform is "linux"

export class WeatherTimeHelper
  static inRange(time: Types.WeatherTime, range: Types.WeatherTimeRange)
    [timeHour, timeMinute] := time |> .split ':' |> .map Number
    [[rangeStartHour, rangeStartMinute], [rangeEndHour, rangeEndMinute]] := range.map (time) -> {
      [hour, minute] := time.split ':'
      return [(Number hour), (Number minute)]
    }
    if timeHour < rangeStartHour or timeHour > rangeEndHour
      return false
    if timeHour is rangeStartHour and timeMinute < rangeStartMinute
      return false
    if timeHour is rangeEndHour and timeMinute > rangeEndMinute
      return false
    return true

export class WeatherEditor
  private root: string
  private debug: boolean
  private skyTexturesRoot: string
  private ltxParser: WeatherLtxParser
  private weathersDirPath: string
  private skyTextureAvgColorCache = {}

  @(args: TWeatherEditorArgs)
    @root = args.root
    @debug = args.debug
    @skyTexturesRoot = args.skyTexturesRoot ?? path.join @root, 'gamedata', 'textures', 'sky'
    @ltxParser = new WeatherLtxParser
    @weathersDirPath := path.join @root, 'gamedata', 'configs', 'environment', 'weathers'

  getSkyTextureAvgColor(skyTextureName: string)
    unless fs.existsSync @skyTexturesRoot
      throw new Error `Sky textures root not found: ${@skyTexturesRoot}`

    unless skyTextureName return
    return new Promise<Types.ColorVector3> (resolve, reject) =>
      skyTextureName = skyTextureName.replace 'sky\\', ''

      if @skyTextureAvgColorCache[skyTextureName]
        return resolve @skyTextureAvgColorCache[skyTextureName]
      
      skyTexturesRoot := @skyTexturesRoot
      skyTexturePath := path.join skyTexturesRoot, `${skyTextureName}.dds`
      unless fs.existsSync skyTexturePath
        throw new Error `Sky texture not found: ${skyTexturePath}`

      pngPath := skyTexturePath.replace '.dds', '.png'
      unless fs.existsSync pngPath
        magick := IS_LINUX ? './magick' : 'magick'
        spawnSync magick, [skyTexturePath, pngPath], { stdio: 'inherit' }

      try
        // We only use the first image for now
        firstImage := skyTexturePath.replace '.dds', '-0.png'
        buffer := await fsp.readFile firstImage
        image := await Jimp.read buffer
        { width, height } := image.bitmap
        x := Math.floor width / 2
        y := height
        { r, g, b } := intToRGBA image.getPixelColor x, y
        colors := [r, g, b] |> .map ((& / 255) |> .toFixed 4 |> parseFloat)
        @skyTextureAvgColorCache[skyTextureName] = colors
        return resolve colors as Types.ColorVector3
      catch error
        return reject error

  cleanUpSkyTextures(dirPath = @skyTexturesRoot)
    unless fs.existsSync @skyTexturesRoot
      throw new Error `Sky textures root not found: ${@skyTexturesRoot}`
    try
      files := fs.readdirSync dirPath
      for file of files
        filePath := path.join dirPath, file
        if fs.statSync(filePath).isDirectory()
          @cleanUpSkyTextures filePath
        else if (file.endsWith '.png') and (fs.existsSync filePath)
          fs.unlinkSync filePath
    catch _error

  patch<TWeatherName extends Types.WeatherName, TTimeRange extends Types.WeatherTimeRange>(args: TPatchArgs<TWeatherName, TTimeRange>)
    { weatherName, timeRange, with: iteratorCb } := args
    result := await @iterateOver weatherName, (def, time) ->
      unless WeatherTimeHelper.inRange time, timeRange then return
      console.info 'Running for', weatherName, '|', time
      iteratorCb def, time
    return @writeIterateResultToWeatherFile result

  fetchAllWeathersNames()
    length := LTX_EXT.length
    return fs.readdirSync @weathersDirPath
      .filter .endsWith LTX_EXT
      .map .slice 0, -length

  private iterateOver<TWeatherName extends Types.WeatherName>(weatherName: TWeatherName, iteratorCb: (def: Types.WeatherDefinition, time: string) => any): TIterateResult<TWeatherName>
    weather := await @parseLtxFile weatherName
    node .= weather
    while node
      if 'time' in node
        await iteratorCb node.entries as Types.WeatherDefinition, node.time
      node = node.next
    return {
      weatherName,
      weather,
    }

  private writeIterateResultToWeatherFile<TWeatherName extends Types.WeatherName>({ weatherName, weather }: TIterateResult<TWeatherName>)
    weatherFilePath := path.join @weathersDirPath, `${weatherName}${LTX_EXT}`
    formatted := @ltxParser.format weather
    unless @debug
      fs.writeFileSync weatherFilePath, formatted

  private parseLtxFile<TWeatherName extends Types.WeatherName>(weatherName: TWeatherName)
    weatherFilePath := path.join @weathersDirPath, `${weatherName}${LTX_EXT}`
    return @ltxParser.parse weatherFilePath

