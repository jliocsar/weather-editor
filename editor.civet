* as fs from node:fs
* as fsp from node:fs/promises
* as path from node:path
{ spawnSync } from child_process

{ Jimp, intToRGBA } from jimp

{ LtxParser, type ParsedLtxSection } from ./ltx-parser.civet
* as Types from ./typedefs.civet
{ clamp } from ./utils.civet

export Types

class CColorVector3
  @(@r: number, @g: number, @b: number)

  get()
    [@r, @g, @b]

  normalize()
    @divide 255
    return this

  divide(div: number | number[] | Types.ColorVector3 | Types.ColorVector4, isArray = Array.isArray div)
    r .= @r
    g .= @g
    b .= @b

    if isArray
      r /= div.0 or 1
      g /= div.1 or 1
      b /= div.2 or 1
    else
      div = div as number
      r /= div
      g /= div
      b /= div

    @r = r as number
    @g = g as number
    @b = b as number

    return this

  multiply(mul: number | number[] | Types.ColorVector3 | Types.ColorVector4, isArray = Array.isArray mul)
    r .= @r
    g .= @g
    b .= @b

    if isArray
      r *= mul.0 or 1
      g *= mul.1 or 1
      b *= mul.2 or 1
    else
      mul = mul as number
      r *= mul
      g *= mul
      b *= mul

    @r = r as number
    @g = g as number
    @b = b as number

    return this

  sum(sum: number | number[] | Types.ColorVector3 | Types.ColorVector4, isArray = Array.isArray sum)
    r .= @r
    g .= @g
    b .= @b

    if isArray
      r += sum.0 or 1
      g += sum.1 or 1
      b += sum.2 or 1
    else
      sum = sum as number
      r += sum
      g += sum
      b += sum

    @r = r as number
    @g = g as number
    @b = b as number

    return this

  subtract(sub: number | number[] | Types.ColorVector3 | Types.ColorVector4, isArray = Array.isArray sub)
    r .= @r
    g .= @g
    b .= @b

    if isArray
      r -= sub.0 or 1
      g -= sub.1 or 1
      b -= sub.2 or 1
    else
      sub = sub as number
      r -= sub
      g -= sub
      b -= sub

    @r = r as number
    @g = g as number
    @b = b as number

    return this

class CColorVector4 < CColorVector3
  @(r: number, g: number, b: number, @a: number)
    super r, g, b

  get()
    rgb := super.get()
    rgb.push @a
    return rgb as Types.ColorVector4

  divide(div: number | number[] | Types.ColorVector3 | Types.ColorVector4)
    isArray := Array.isArray div
    a .= @a

    if isArray
      a /= div.3 or 1
    else
      div = div as number
      a /= div

    @a = a as number
    super.divide div, isArray

  multiply(mul: number | number[] | Types.ColorVector3 | Types.ColorVector4)
    isArray := Array.isArray mul
    a .= @a

    if isArray
      a *= mul.3 or 1
    else
      mul = mul as number
      a *= mul

    @a = a as number
    super.multiply mul, isArray

  sum(sum: number | number[] | Types.ColorVector3 | Types.ColorVector4)
    isArray := Array.isArray sum
    a .= @a

    if isArray
      a += sum.3 or 1
    else
      sum = sum as number
      a += sum

    @a = a as number
    super.sum sum, isArray

  subtract(sub: number | number[] | Types.ColorVector3 | Types.ColorVector4)
    isArray := Array.isArray sub
    a .= @a

    if isArray
      a -= sub.3 or 1
    else
      sub = sub as number
      a -= sub

    @a = a as number
    super.subtract sub, isArray

export class WeatherLtxNormalizer
  colorVector3(value: Types.ColorVector3)
    return value.map(@zeroToOne) as Types.ColorVector3
  
  colorVector4(value: Types.ColorVector4)
    return value.map(@zeroToOne) as Types.ColorVector4

  zeroToThousand(value: number)
    return clamp value, 0, 1000

  zeroToOne(value: number)
    return clamp value, 0, 1

type TIterateResult<TWeatherName extends Types.WeatherName> =
  weatherName: TWeatherName
  weather: Partial<ParsedLtxSection>

type TWeatherEditorArgs =
  root: string
  debug?: boolean
  skyTexturesRoot?: string

type NormalizerMap = {
  [Key in keyof Types.WeatherDefinition]?: keyof WeatherLtxNormalizer
}

type TPatchArgs<TWeatherName extends Types.WeatherName, TTimeRange extends Types.WeatherTimeRange> =
  weatherName: TWeatherName
  timeRange: TTimeRange
  with: (def: Types.WeatherDefinition, time: Types.WeatherTime) => void

LTX_EXT := '.ltx'
DDS_EXT := '.dds'
PNG_EXT := '.png'
IS_LINUX := process.platform is "linux"

export function vector3(r: number, g: number, b: number)
  new CColorVector3 r, g, b

export function vector4(r: number, g: number, b: number, a: number)
  new CColorVector4 r, g, b, a

export class WeatherEditor
  private readonly root: string
  private readonly debug: boolean
  private readonly skyTexturesRoot: string
  private readonly weathersDirPath: string
  private readonly ltxParser: LtxParser
  private readonly normalizer: WeatherLtxNormalizer
  private readonly skyTextureAvgColorCache = {}
  private readonly normalizeMap: NormalizerMap = {
    ambient_color: 'colorVector3'
    clouds_color: 'colorVector4'
    far_plane: 'zeroToThousand'
    fog_color: 'colorVector3'
    fog_density: 'zeroToOne'
    fog_distance: 'zeroToThousand'
    hemisphere_color: 'colorVector4'
    rain_color: 'colorVector3'
    rain_density: 'zeroToOne'
    sky_color: 'colorVector3'
    sky_rotation: 'zeroToOne'
    sun_color: 'colorVector3'
    sun_shafts_intensity: 'zeroToOne'
    water_intensity: 'zeroToOne'
  }

  @(args: TWeatherEditorArgs)
    @root = args.root
    @debug = args.debug
    @skyTexturesRoot = args.skyTexturesRoot ?? path.join @root, 'gamedata', 'textures', 'sky'
    @ltxParser = new LtxParser
    @weathersDirPath := path.join @root, 'gamedata', 'configs', 'environment', 'weathers'
    @normalizer := new WeatherLtxNormalizer

  getSkyTextureAvgColor(skyTextureName: string)
    unless fs.existsSync @skyTexturesRoot
      throw new Error `Sky textures root not found: ${@skyTexturesRoot}`

    unless skyTextureName return
    return new Promise<Types.ColorVector3> (resolve, reject) =>
      skyTextureName = skyTextureName.replace 'sky\\', ''

      if @skyTextureAvgColorCache[skyTextureName]
        return resolve @skyTextureAvgColorCache[skyTextureName]
      
      skyTexturesRoot := @skyTexturesRoot
      skyTexturePath := path.join skyTexturesRoot, `${skyTextureName}${DDS_EXT}`
      unless fs.existsSync skyTexturePath
        throw new Error `Sky texture not found: ${skyTexturePath}`

      pngPath := skyTexturePath.replace DDS_EXT, PNG_EXT
      unless fs.existsSync pngPath
        magick := IS_LINUX ? './magick' : 'magick'
        spawnSync magick, [skyTexturePath, pngPath], { stdio: 'inherit' }

      try
        // We only use the first image for now
        firstImage := skyTexturePath.replace DDS_EXT, `-0${PNG_EXT}`
        buffer := await fsp.readFile firstImage
        image := await Jimp.read buffer
        { width, height } := image.bitmap
        // For now we're grabbing the pixel from the middle bottom, which is essentially the color that the game uses
        // to create that skybox/cubemap thing idk the name
        x := Math.floor width / 2
        y := height - 1
        { r, g, b } := intToRGBA image.getPixelColor x, y
        // Format the vector to the engine format (color / 255)
        colors := vector3(r, g, b).normalize().get() as Types.ColorVector3
        @skyTextureAvgColorCache[skyTextureName] = colors
        return resolve colors
      catch error
        return reject error

  cleanUpSkyTextures(dirPath = @skyTexturesRoot)
    unless fs.existsSync @skyTexturesRoot
      throw new Error `Sky textures root not found: ${@skyTexturesRoot}`
    try
      files := fs.readdirSync dirPath
      for file of files
        filePath := path.join dirPath, file
        if fs.statSync(filePath).isDirectory()
          @cleanUpSkyTextures filePath
        else if (file.endsWith PNG_EXT) and (fs.existsSync filePath)
          fs.unlinkSync filePath
    catch _error

  patch<TWeatherName extends Types.WeatherName, TTimeRange extends Types.WeatherTimeRange>(args: TPatchArgs<TWeatherName, TTimeRange>)
    { weatherName, timeRange, with: iteratorCb } := args
    result := await @iterateOver weatherName, (def, time) =>
      unless @inTimeRange time, timeRange then return
      console.info 'Running for', weatherName, '|', time
      iteratorCb def, time
      @normalizeDef def
    return @writeIterateResultToWeatherFile result

  fetchAllWeathersNames()
    length := LTX_EXT.length
    return fs.readdirSync @weathersDirPath
      .filter .endsWith LTX_EXT
      .map .slice 0, -length

  private normalizeDef(def: Types.WeatherDefinition)
    normalizeMapEntries := Object.entries @normalizeMap
    normalized := Object.assign {}, def

    for [key, normalizer] of normalizeMapEntries
      value := normalized[key]
      if value is not undefined
        normalized[key] = @normalizer[normalizer] normalized[key]

    return normalized

  private inTimeRange(time: Types.WeatherTime, range: Types.WeatherTimeRange)
    [timeHour, timeMinute] := time |> .split ':' |> .map Number
    [[rangeStartHour, rangeStartMinute], [rangeEndHour, rangeEndMinute]] := range.map (time) => {
      [hour, minute] := time.split ':'
      return [(Number hour), (Number minute)]
    }
    if timeHour < rangeStartHour or timeHour > rangeEndHour
      return false
    if timeHour is rangeStartHour and timeMinute < rangeStartMinute
      return false
    if timeHour is rangeEndHour and timeMinute > rangeEndMinute
      return false
    return true

  private iterateOver<TWeatherName extends Types.WeatherName>(weatherName: TWeatherName, iteratorCb: (def: Types.WeatherDefinition, time: string) => any): TIterateResult<TWeatherName>
    weather := await @parseLtxFile weatherName
    node .= weather
    while node
      if 'section' in node
        await iteratorCb node.entries as Types.WeatherDefinition, node.section
      node = node.next
    return {
      weatherName,
      weather,
    }

  private writeIterateResultToWeatherFile<TWeatherName extends Types.WeatherName>({ weatherName, weather }: TIterateResult<TWeatherName>)
    weatherFilePath := path.join @weathersDirPath, `${weatherName}${LTX_EXT}`
    formatted := @ltxParser.format weather
    unless @debug
      fs.writeFileSync weatherFilePath, formatted

  private parseLtxFile<TWeatherName extends Types.WeatherName>(weatherName: TWeatherName)
    weatherFilePath := path.join @weathersDirPath, `${weatherName}${LTX_EXT}`
    return @ltxParser.parse weatherFilePath

