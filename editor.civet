* as fs from node:fs
* as fsp from node:fs/promises
* as path from node:path
{ spawnSync } from child_process

{ Jimp, intToRGBA } from jimp

{ WeatherLtxParser, type ParsedWeatherLtxSection } from ./ltx-parser.civet
* as Types from ./typedefs.civet
{ clamp } from ./utils.civet

export Types

class WeatherLtxNormalizer
  colorVector3(field: Types.ColorVector3)
    return (field.map (color) => clamp color, 0, 1) as Types.ColorVector3
  
  colorVector4(field: Types.ColorVector4)
    return (field.map (color) => clamp color, 0, 1) as Types.ColorVector4

  zeroToThousand(field: number)
    return clamp field, 0, 1000

  zeroToOne(field: number)
    return clamp field, 0, 1

type TIterateResult<TWeatherName extends Types.WeatherName> =
  weatherName: TWeatherName
  weather: Partial<ParsedWeatherLtxSection>

type TWeatherEditorArgs =
  root: string
  debug?: boolean
  skyTexturesRoot?: string

type NormalizerMap = {
  [Key in keyof Types.WeatherDefinition]?: keyof WeatherLtxNormalizer
}

type TPatchArgs<TWeatherName extends Types.WeatherName, TTimeRange extends Types.WeatherTimeRange> =
  weatherName: TWeatherName
  timeRange: TTimeRange
  with: (def: Types.WeatherDefinition, time: Types.WeatherTime) => void

LTX_EXT := '.ltx'
IS_LINUX := process.platform is "linux"
``
export class WeatherEditor
  private readonly root: string
  private readonly debug: boolean
  private readonly skyTexturesRoot: string
  private readonly ltxParser: WeatherLtxParser
  private readonly weathersDirPath: string
  private readonly skyTextureAvgColorCache = {}
  private readonly normalizer: WeatherLtxNormalizer
  private readonly normalizeMap: NormalizerMap = {
    ambient_color: 'colorVector3'
    clouds_color: 'colorVector4'
    far_plane: 'zeroToThousand'
    fog_color: 'colorVector3'
    fog_density: 'zeroToOne'
    fog_distance: 'zeroToThousand'
    hemisphere_color: 'colorVector4'
    rain_color: 'colorVector3'
    rain_density: 'zeroToOne'
    sky_color: 'colorVector3'
    sky_rotation: 'zeroToOne'
    sun_color: 'colorVector3'
    sun_shafts_intensity: 'zeroToOne'
    water_intensity: 'zeroToOne'
  }

  @(args: TWeatherEditorArgs)
    @root = args.root
    @debug = args.debug
    @skyTexturesRoot = args.skyTexturesRoot ?? path.join @root, 'gamedata', 'textures', 'sky'
    @ltxParser = new WeatherLtxParser
    @weathersDirPath := path.join @root, 'gamedata', 'configs', 'environment', 'weathers'
    @normalizer := new WeatherLtxNormalizer

  getSkyTextureAvgColor(skyTextureName: string)
    unless fs.existsSync @skyTexturesRoot
      throw new Error `Sky textures root not found: ${@skyTexturesRoot}`

    unless skyTextureName return
    return new Promise<Types.ColorVector3> (resolve, reject) =>
      skyTextureName = skyTextureName.replace 'sky\\', ''

      if @skyTextureAvgColorCache[skyTextureName]
        return resolve @skyTextureAvgColorCache[skyTextureName]
      
      skyTexturesRoot := @skyTexturesRoot
      skyTexturePath := path.join skyTexturesRoot, `${skyTextureName}.dds`
      unless fs.existsSync skyTexturePath
        throw new Error `Sky texture not found: ${skyTexturePath}`

      pngPath := skyTexturePath.replace '.dds', '.png'
      unless fs.existsSync pngPath
        magick := IS_LINUX ? './magick' : 'magick'
        spawnSync magick, [skyTexturePath, pngPath], { stdio: 'inherit' }

      try
        // We only use the first image for now
        firstImage := skyTexturePath.replace '.dds', '-0.png'
        buffer := await fsp.readFile firstImage
        image := await Jimp.read buffer
        { width, height } := image.bitmap
        x := Math.floor width / 2
        y := height
        { r, g, b } := intToRGBA image.getPixelColor x, y
        colors := [r, g, b] |> .map ((& / 255) |> .toFixed 4 |> parseFloat)
        @skyTextureAvgColorCache[skyTextureName] = colors
        return resolve colors as Types.ColorVector3
      catch error
        return reject error

  cleanUpSkyTextures(dirPath = @skyTexturesRoot)
    unless fs.existsSync @skyTexturesRoot
      throw new Error `Sky textures root not found: ${@skyTexturesRoot}`
    try
      files := fs.readdirSync dirPath
      for file of files
        filePath := path.join dirPath, file
        if fs.statSync(filePath).isDirectory()
          @cleanUpSkyTextures filePath
        else if (file.endsWith '.png') and (fs.existsSync filePath)
          fs.unlinkSync filePath
    catch _error

  patch<TWeatherName extends Types.WeatherName, TTimeRange extends Types.WeatherTimeRange>(args: TPatchArgs<TWeatherName, TTimeRange>)
    { weatherName, timeRange, with: iteratorCb } := args
    result := await @iterateOver weatherName, (def, time) =>
      unless @inTimeRange time, timeRange then return
      console.info 'Running for', weatherName, '|', time
      iteratorCb def, time
      @normalizeDef def
    return @writeIterateResultToWeatherFile result

  fetchAllWeathersNames()
    length := LTX_EXT.length
    return fs.readdirSync @weathersDirPath
      .filter .endsWith LTX_EXT
      .map .slice 0, -length

  private normalizeDef(def: Types.WeatherDefinition)
    normalizeMapEntries := Object.entries @normalizeMap
    normalized := Object.assign {}, def

    for [field, normalizer] of normalizeMapEntries
      if field in normalized
        normalized[field] = @normalizer[normalizer] normalized[field]

    return normalized

  private inTimeRange(time: Types.WeatherTime, range: Types.WeatherTimeRange)
    [timeHour, timeMinute] := time |> .split ':' |> .map Number
    [[rangeStartHour, rangeStartMinute], [rangeEndHour, rangeEndMinute]] := range.map (time) => {
      [hour, minute] := time.split ':'
      return [(Number hour), (Number minute)]
    }
    if timeHour < rangeStartHour or timeHour > rangeEndHour
      return false
    if timeHour is rangeStartHour and timeMinute < rangeStartMinute
      return false
    if timeHour is rangeEndHour and timeMinute > rangeEndMinute
      return false
    return true

  private iterateOver<TWeatherName extends Types.WeatherName>(weatherName: TWeatherName, iteratorCb: (def: Types.WeatherDefinition, time: string) => any): TIterateResult<TWeatherName>
    weather := await @parseLtxFile weatherName
    node .= weather
    while node
      if 'time' in node
        await iteratorCb node.entries as Types.WeatherDefinition, node.time
      node = node.next
    return {
      weatherName,
      weather,
    }

  private writeIterateResultToWeatherFile<TWeatherName extends Types.WeatherName>({ weatherName, weather }: TIterateResult<TWeatherName>)
    weatherFilePath := path.join @weathersDirPath, `${weatherName}${LTX_EXT}`
    formatted := @ltxParser.format weather
    unless @debug
      fs.writeFileSync weatherFilePath, formatted

  private parseLtxFile<TWeatherName extends Types.WeatherName>(weatherName: TWeatherName)
    weatherFilePath := path.join @weathersDirPath, `${weatherName}${LTX_EXT}`
    return @ltxParser.parse weatherFilePath

